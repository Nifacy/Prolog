%% Сначала используем логику поиска решения пролога. Если поиск заканчивается неуспешно, то пролог
%% делает откат назад, пробуя искать другие решения. Здесь мы делаем следующее: находим решение,
%% Сохраняем его в базу данных пролога и кидаем fail, чтобы пролог дальше искал другие решения
my_findall(Var, Expr, _) :- call(Expr), assertz(found_result(Var)), fail.

%% Прошлый предикат всегда будет заканчиваться неуспехом. Если пролог не смог найит решение используя
%% одно из определений предиката, он переключается на следующее. Этим мы и пользуемся, чтобы после того
%% как мы добавили все решения в бд, собрать их в список
my_findall(_, _, Results) :- collect_results(Results).


%% Работает следующим образом: ищем факт found_result, унифицируем переменную X с найденным фактом, удаляем найденный факт,
%% добавляем элемент в список, идем искать следующие. Отсечение нужно, чтобы пролог не пошел к следующему определению
%% предиката
collect_results([X | T]) :- retract(found_result(X)), !, collect_results(T).
collect_results([]).
